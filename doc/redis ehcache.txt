http://www.cnblogs.com/gomysql/p/4395504.html  Redis Cluster 3.0搭建与使用
http://www.cnblogs.com/gomysql/p/3617238.html  主从


http://www.ttlsa.com/redis/redis-keepalived-achieve-high-availability/
http://www.ttlsa.com/python/redis-rdb-tools-analysis-of-reids-dump-file-and-memory-usage/
http://my.oschina.net/guol/blog/182265
Redis 监控最直接的方法就是使用系统提供的 info 命令，redis-cli info   http://www.cnblogs.com/kaituorensheng/p/3979298.html

http://os.51cto.com/art/201301/379151.htm
http://www.nkrode.com/article/real-time-dashboard-for-redis

http://qiniuppt.qiniudn.com/liuqi.pdf  codis

http://www.oschina.net/code/snippet_1046345_44151   redis 3.0
http://blog.csdn.net/xu470438000/article/details/42971091


http://blog.csdn.net/wen158809179/article/details/8270251  备份
http://www.iigrowing.cn/redis-fu-wu-qi-an-zhuang.html
#备份  redis-cli save  
#关闭redis服务器  redis-cli shutdown  

保存快照有save和bgsave两个命令
通过配置文件 从数据库的配置文件中加入slaveof master-ip master-port，主数据库无需配置
SLAVEOF NO ONE可以是当前数据库停止接收其他数据库的同步，转成主数据库
更新日志检查 ，加Cfix参数为修复log文件 redis-check-aof appendonly.aof
检查本地数据库文件 redis-check-dump  dump.rdb
redis-cli info查询系统信息
http://redis4you.com/articles.php?id=010   备份  daily backup we can add "date '+%a'"
http://zdk.github.io/redis-backup-and-restore/
http://hunng.com/2014/08/08/redis-install-and-config/

http://wklken.me/posts/2013/10/19/redis-base.html  笔记
http://openmymind.net/redis.pdf   little book

http://qatang.com/2014/03/18/jedis%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/
http://qatang.com/2014/03/18/spring-data-redis%E4%BD%BF%E7%94%A8/#more-32
http://redis.cn/topics/pubsub.html

在默认情况下， Redis 将数据库快照保存在名字为 dump.rdb 的二进制文件中
http://redis.readthedocs.org/en/latest/topic/persistence.html
http://redis.io/topics/memory-optimization  dbfilename dump.rdb 

redis查看当前所有的key KEYS *
查看当前redis的配置信息 CONFIG GET *
如果不设置maxmemory或者设置为0 64位系统不限制内存，32位系统最多使用3GB内存。
http://www.nginx.cn/2500.html
http://www.infoq.com/cn/articles/tq-why-choose-redis
http://www.infoq.com/cn/articles/tq-redis-memory-usage-optimization-storage
http://hilojack.com/p/redis/
http://junjiewen.com/blog/2012/12/20/redis/

http://www.slideshare.net/ayanamist/redis-v2
http://www.slideshare.net/vincent253/redis-37221509


http://www.ibm.com/developerworks/cn/opensource/os-cn-spring-cache/   cache
http://blog.joshuawhite.com/java/caching-with-spring-data-redis/  redis cache
http://haohaoxuexi.iteye.com/blog/2123030
Since Ehcache 2.5, you’ve got Automatic Resource Control (ARC),  ARC helps you to define a cache by memory size.  http://java.dzone.com/articles/ehcache-size-configuration
http://raychase.iteye.com/blog/1545906


logfile /var/log/redis/redis.log
pidfile /var/run/redis.pid
save <seconds> <changes>
dbfilename dump.rdb
slaveof <masterip> <masterport>
appendfilename "appendonly.aof"

maxmemory 700mb
maxmemory-policy volatile-lru

databases：开启数据库的数量
save * *：保存快照的频率，第一个*表示多长时间，第三个*表示执行多少次写操作。在一定时间内执行一定数量的写操作时，自动保存快照。可设置多个条件。
dbfilename：数据快照文件名（只是文件名，不包括目录）
dir：数据快照的保存目录（这个是目录）
appendonly：是否开启appendonlylog，开启的话每次写操作会记一条log，这会提高数据抗风险能力，但影响效率。
appendfsync：appendonlylog如何同步到磁盘（三个选项，分别是每次写都强制调用fsync、每秒启用一次fsync、不调用fsync等待系统自己同步）
http://www.cnblogs.com/shanyou/archive/2012/01/28/2330451.html
http://www.cnblogs.com/shanyou/archive/2012/09/04/2670972.html
http://heylinux.com/archives/1932.html

第一次Slave向Master同步的实现是：Slave向Master发出同步请求，Master先dump出rdb文件，然后将rdb文件全量传输给slave，然后Master把缓存的命令转发给Slave，初次同步完成。
第二次以及以后的同步实现是：Master将变量的快照直接实时依次发送给各个Slave。
但不管什么原因导致Slave和Master断开重连都会重复以上两个步骤的过程。Redis的主从复制是建立在内存快照的持久化基础上的，只要有Slave就一定会有内存快照发生。
由于在使用AOF持久化方式时，Redis会将每一个收到的写命令都通过Write函数追加到文件中，类似于MySQL的binlog。
Redis提供了bgrewriteaof命令。收到此命令后Redis将使用与快照类似的方式将内存中的数据以命令的方式保存到临时文件中，最后替换原来的文件，以此来实现控制AOF文件的增长。
将整个内存中的数据库内容用命令的方式重写了一个新的AOF文件。

将Slave上的同步状态取消，避免主库在未完成数据恢复前就重启，进而直接覆盖掉从库上的数据，导致所有的数据丢失。SLAVEOF NO ONE

Pre-Sharding方案实际上可以理解为预先分配一个相当大的集合，对Key哈希的结果落在这个集合中，集合的每个元素又与具体的物理节点存在多对一的路由映射关系，这张路由表由一个配置中心进行维护。
对在线纵向扩容的支持，直接一系列config set maxmemory完事
Redis在主从复制高可用方面也经历了较长的迭代，从最初2.4版本备受诟病的全量同步，到2.6版本终于实现了增量同步
订阅方式同样可以走各种配置中心。
类似Twitter的twemproxy（ https://github.com/twitter/twemproxy ），或者百度的的bdrp（ https://github.com/ops-baidu/bdrp ）或者前述的豌豆荚codis，以及京东的Redis集群都是使用了一层Proxy进行透传请求。这样只需要Proxy能够订阅到物理节点的变更，并自动加载即可。订阅方式同样可以走各种配置中心。
http://www.oschina.net/p/codis      http://www.cnblogs.com/shanyou/p/4268896.html
http://engineering.xueqiu.com/blog/2014/12/26/redis-capacity-planning/?utm_source=tuicool


Redis 3.0版本相对于2.8版本带来的主要新特性包括：
实现了分布式的Redis即Redis Cluster，从而做到了对集群的支持；
CONFIG SET能够接受不同单位的内存值，如CONFIG SET maxmemory 1gb
http://www.infoq.com/cn/articles/effective-ops-part-03?utm_source=infoq&utm_medium=popular_widget&utm_content=presentation&utm_campaign=popular_content_list