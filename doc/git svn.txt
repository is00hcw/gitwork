http://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html
http://www.codeceo.com/article/how-to-use-git-flow.html
http://www.bootcss.com/p/git-guide/  git - 简易指南

Git 保存的不是文件差异或者变化量，而只是一系列文件快照。在 Git 中提交时，会保存一个提交（commit）对象，该对象包含一个指向暂存内容快照的指针，包含本次提交的作者等相关附属信息，包含零个或多个指向该提交对象的父对象指针。 当使用 git commit 新建一个提交对象前，Git 会先计算每一个子目录的校验和，然后在 Git 仓库中将这些目录保存为树（tree）对象。
git diff  此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。
若要看已经暂存起来的文件和上次提交时的快照之间的差异，可以用 git diff --cached 命令。
Git 提供了一个跳过使用暂存区域的方式，只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤
要移除跟踪但不删除文件，以便稍后在 .gitignore 文件中补上，用 --cached 选项即可git rm --cached readme.txt
想要撤消刚才的提交操作，可以使用 --amend 选项重新提交：git commit --amend  如果刚才提交时忘了暂存某些修改，可以先补上暂存操作，然后再运行 --amend 提交：
https://my.oschina.net/qiangdada/blog/800093
也可以加上 -v 选项（译注：此为 --verbose 的简写，取首字母），显示对应的克隆地址： git remote -v 
Git 又是如何创建一个新的分支的呢？答案很简单，创建一个新的分支指针。 Git 是如何知道你当前在哪个分支上工作的呢？其实答案也很简单，它保存着一个名为 HEAD 的特别指针。在 Git 中，它是一个指向你正在工作中的本地分支的指针。
换句话说，如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）。
在解决了所有文件里的所有冲突后，运行 git add 将把它们标记为已解决状态（实际上就是来一次快照保存到暂存区域）。 
https://my.oschina.net/qiangdada/blog/808527
请务必牢记这些分支全部都是本地分支，这一点很重要。当你在使用分支及合并的时候，一切都是在你自己的 Git 仓库中进行的 ― 完全不涉及与服务器的交互。
一次 Git 克隆会建立你自己的本地分支 master 和远程分支 origin/master，并且将它们都指向 origin 上的 master 分支。 若想把远程分支叫作 awesomebranch，可以用 git push origin serverfix:awesomebranch 来推送数据。
git push [远程名] [本地分支]:[远程分支] 语法，如果省略 [本地分支]，那就等于是在说“在这里提取空白然后把它变成[远程分支]”。
在 Git 里，这种操作叫做衍合（rebase）。有了 rebase 命令，就可以把在一个分支里提交的改变移到另一个分支里重放一遍。
git rebase [主分支] [特性分支] 命令会先取出特性分支 server，然后在主分支 master 上重演
一旦分支的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作。进行衍合的时候，实际上抛弃了一些显存的提交对象而创造了一些类似但不同的新的提交对象，如果你把原来分支中的提交对象发布出去，并且其他人更新下载后在其基础上开展工作，而稍后你又用Git rebase抛弃这些提交对象，把新的重演后的提交对象发布出去的话，你的合作者就不得不重新合并他们的工作，这样当你再次从他们那里获取内容的时候，提交历史就会变得一团糟。


http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html  常用命令
http://www.ruanyifeng.com/blog/2015/08/git-use-process.html
http://www.ruanyifeng.com/blog/2012/07/git.html
http://www.tuicool.com/articles/feIBJb   gitflow
http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000  廖雪峰
http://www.ruanyifeng.com/blog/2014/06/git_remote.html
主分支Master 首先，代码库应该有一个、且仅有一个主分支。所有提供给用户使用的正式版本，都在这个主分支上发布. Git主分支的名字，默认叫做Master。它是自动建立的，版本库初始化以后，默认就是在主分支在进行开发。
开发分支Develop 主分支只用来分布重大版本，日常开发应该在另一条分支上完成。我们把开发用的分支，叫做Develop。
  # 切换到Master分支
　　git checkout master
　# 对Develop分支进行合并
　　git merge --no-ff develop
临时性分支主要有三种：　　* 功能（feature）分支　　* 预发布（release）分支　　* 修补bug（fixbug）分支
git commit --verbose   git commit 命令的verbose参数，会列出 diff 的结果。
第一行是不超过50个字的提要，然后空一行，罗列出改动原因、主要变动、以及需要注意的问题。最后，提供对应的网址（比如Bug ticket）。


主要分支
master: 永远处在 production-ready 状态
develop: 最新的下次发芽发状态
支援性分支
Feature branches: 开发新功能都从 develop 分支出来，完成后 merge 回 develop
Release branches: 准备要 release 的版本，只修 bugs。从 develop 分支出来，完成后 merge 回 master 和 develop
Hotfix branches: 等不及 release 版本就必须马上修 master 赶上线的情况。会从 master 分支出来，完成后 merge 回 master 和 develop


http://www.cnblogs.com/linjiqin/p/3772681.html   Git和Code Review流程
https://github.com/oldratlee/translations/blob/master/git-workflows-and-tutorials/workflow-feature-branch.md   git功能分支工作流

gitlab ci
The .gitlab-ci.yml file tells the GitLab runner what do to. By default it runs three stages: build, test, and deploy.
If everything runs OK (no non-zero return values), you'll get a nice green checkmark
So in brief, the steps needed to have a working CI can be summed up to:
Add .gitlab-ci.yml to the root directory of your repository
Configure a Runner
the build will be automagically started by the Runner and will appear under the project's /builds page.
http://doc.gitlab.com/ce/ci/quick_start/README.html


http://www.wtoutiao.com/p/hc5qVr.html  ―17款最佳的代码审查工具
http://liuzhichao.com/p/1974.html   Phabricator 实践之安装
https://hub.docker.com/r/yesnault/docker-phabricator/ 
https://liuzhichao.com/p/1981.html
https://liuzhichao.com/p/1992.html
http://pennchone.lofter.com/post/b6a79_13f5636

http://blogs.endjin.com/2015/01/using-smartgit-to-follow-the-gitflow-branching-and-workflow-model/?utm_source=tuicool  smartgit and gitflow
http://www.ituring.com.cn/article/56870    基于git的源代码管理模型――git flow
http://www.jeffkit.info/2010/12/842/
yum install gitflow 
apt-get install git-flow
https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow
http://www.cnblogs.com/wubaiqing/archive/2011/12/18/2271724.html
http://www.berlinix.com/it/gitflow.php
 
http://debugo.com/gitosis/

git fetch origin 会抓取从你上次克隆以来别人上传到此远程仓库中的所有更新（或是上次 fetch 以来别人提交的更新）。有一点很重要，需要记住，fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好了，才能手工合并。
http://www.cnblogs.com/cocowool/archive/2012/02/17/2356125.html

http://blog.csdn.net/forever_wind/article/details/37506389
http://blog.jobbole.com/53573/


http://pinkyjie.com/2014/08/02/git-notes-part-1/
http://marklodato.github.io/visual-git-guide/index-zh-cn.html
http://www.sourcetreeapp.com/
http://www.syntevo.com/smartgit/download
http://www.sourcetreeapp.com/update/windowsupdates.txt